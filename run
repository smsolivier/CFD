#!/usr/bin/env python3

import Timer 
import os
import sys 

import argparse 

from shutil import copyfile # copy files 


####################### My Changes ########################
from generateInlet import *
###########################################################

''' Runs GEMIX project 
	Changes 
		decomposeParDict, blockMeshDict, fvSchemes, fvSolution, turbulenceProperties 
	at runtime for variable 
		x,y,z processor decomposition 
		Nx1, Nx2, Ny, Nz number of cells 
		switch on 3D modeling 
			changes empty to wall and reflecting 
		turbulence modeling 
''' 

# get command line values 
# description
parser = argparse.ArgumentParser(description='run interFoam in parallel')
# number of processors in x, y, z 
parser.add_argument('-np', nargs=3, default=[4,1,1], metavar=('Nx','Ny','Nz'),
	help='number of processors in x y z')
# number of cells in x_inlet, x_mixing, y and z
parser.add_argument('-N', 
	nargs=4, 
	default=[10,30,10,1], 
	metavar=('NxInlet', 'NxMixing', 'Ny', 'Nz'),
	help='number of cells'
	)
# run in 3D 
parser.add_argument('-threeD', action='store_true', default=False, help='run in 3D')
# use k-Epsilon 
parser.add_argument('-ke', action='store_true',	help='use k-Epsilon turbulence model')
# use k-Omega 
parser.add_argument('-ko', action='store_true', help='use k-Omega turbulence model')
# use laminar 
parser.add_argument('-laminar', action='store_true', help='turn off turbulence')
# bool for send notification when done, default to on 
parser.add_argument('-quiet', action='store_true', help='suppress notification when done')
# make mesh only 
parser.add_argument('-setupOnly', action='store_true', help='run setup commands but do not run interFoam')
# don't remove previous times 
parser.add_argument('-cont', action='store_false', help='continue from latest time')
# use simple geometry 
parser.add_argument('-simple', action='store_true', help='use geometry without angled inlets')



####################### My Changes ########################
parser.add_argument('-condition', nargs=1, default='1.0', metavar='inletVelocity', help = 'Specify the inlet velocity (0.6|1.0)')
parser.add_argument('-interpolation', nargs=1, default='linear', metavar='scheme', help = 'Specify the interpolation method to be used on the inlet conditions (nearest|linear|cubic)\nI plan to add a b-spline interpolation method')
parser.add_argument('-PLOT', action='store_true', help='Show plots of the inlet cell centers and the corresponding interpolated inlet conditions')
parser.add_argument('-STATUS', action='store_true', help='Display the status of the run')
###########################################################

# parse arguments 
args = parser.parse_args()

####################### My Changes ########################
# Double check that the input arguments are valid
if not(''.join(args.condition) == '0.6'
	   or ''.join(args.condition) == '.6'
	   or ''.join(args.condition) == '1.0'
	   or ''.join(args.condition) == '1'):
	error('Invalid inlet condition - use either \'0.6\' or \'1.0\'')
if not(''.join(args.interpolation) == 'nearest'
	   or ''.join(args.interpolation) == 'linear'
	   or ''.join(args.interpolation) == 'cubic'):
	error('Invalid interpolation method - use either \'nearest\', \'linear\', or \'cubic\'')
###########################################################

# get number of processors in x, y, z 
npx = int(args.np[0])
npy = int(args.np[1])
npz = int(args.np[2])

np = npx * npy * npz # total number of cells 

# number of cells 
Nx1 = int(args.N[0])
Nx2 = int(args.N[1])
Ny = int(args.N[2])
Nz = int(args.N[3])

NVols = (Nx1 + Nx2) * Ny * Nz 

# --- change turbulence model --- 
turbDir = 'kOmega/' # default model 
if (args.ke == True):
	turbDir = 'kEpsilon/' 
elif (args.laminar == True):
	turbDir = 'laminar/'

# copy fvSchemes, fvSolution, turbulenceProperties to run locations 
copyfile(turbDir + 'fvSchemes', 'system/fvSchemes')
copyfile(turbDir + 'fvSolution', 'system/fvSolution')
copyfile(turbDir + 'turbulenceProperties', 'constant/turbulenceProperties')

# handle alert 
ALERT = True 
if (args.quiet == True):
	ALERT = False 


# --- write decomposeParDict --- 
decompName = 'system/decomposeParDict'
# read in current file 
f = open(decompName, 'r')
string = '' 
for line in f:
	# change number of subdomains 
	if (line.startswith('numberOfSubdomains')):
		string += 'numberOfSubdomains ' + str(np) + ';\n'

	# change Nx Ny Nz 
	elif ('n (' in line):
		string += '    n (' + str(npx) + ' ' + str(npy) + ' ' + str(npz) + '); \n'

	# copy everything else 
	else:
		string += line 

f.close()

# write changes to file 
out = open(decompName, 'w')
out.write(string)
out.close()


# --- write blockMesh --- 
# change blockMeshDict location 
if (args.simple): # copy simple geometry 
	copyfile('mesh/simple', 'system/blockMeshDict')
else: # use better geometry 
	blockDictName = 'mesh/2D'
	if (args.threeD == True):
		blockDictName = 'mesh/3D'

	f = open('mesh/top', 'r')
	string = '' 
	for line in f:

		# change Nx1 
		if (line.startswith('Nx1 ')):
			string += 'Nx1 ' + str(Nx1) + '; \n'

		# change Nx2 
		elif (line.startswith('Nx2 ')):
			string += 'Nx2 ' + str(Nx2) + '; \n' 

		# change Ny 
		elif (line.startswith('Ny ')):
			string += 'Ny ' + str(Ny) + '; \n' 

		# change Nz 
		elif (line.startswith('Nz ')):
			string += 'Nz ' + str(Nz) + '; \n' 

		# leave everything else 
		else:
			string += line 
	f.close()
	f = open(blockDictName, 'r')
	for line in f:
		string += line 
	f.close()
	# write changes to blockMeshDict 
	out = open('system/blockMeshDict', 'w')
	out.write(string)
	out.close()


# --- run commands --- 
def runcmd(cmd):
	''' run command cmd and exit if errors ''' 
	x = os.system(cmd)
	if (x != 0):
		sys.exit()

tt = Timer.timer() # start timer 

if (args.cont):
	runcmd('foamListTimes -rm') # delete previous time steps 

	if (os.path.isfile('0/yPlus')): # remove previous yPlus 
		runcmd('rm 0/yPlus')

	runcmd('blockMesh') # generate mesh 

	####################### My Changes ########################
	generateInlet(args.condition, args.interpolation, args.PLOT, args.STATUS)
	###########################################################	

if (not(args.setupOnly)): # run if not in setupOnly mode 

	# decompose for parallel run, -force overwrite current directories 
	if (args.cont):
		runcmd('decomposePar -force') 

	# run pipe into log 
	runcmd('mpirun -np ' + str(np) + ' interFoam -parallel | tee log')

	runcmd('reconstructPar') # reconstruct parallel folders 

	runcmd('interFoam -postProcess -func yPlus') # generate yPlus 

print('Number of Volumes =', NVols)

time, str = tt.stop() # end timer 


# make notification if wall time is longer than a minute 
if (time > 60 and ALERT):
	os.system('notify-send --urgency=low -i " " "openfoam done" \
		"run completed in %s"' % (str))
